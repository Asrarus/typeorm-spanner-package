{"version":3,"sources":["../browser/src/driver/spanner/SpannerQueryRunner.ts"],"names":[],"mappings":"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","file":"SpannerQueryRunner.js","sourcesContent":["import {QueryRunner} from \"../../query-runner/QueryRunner\";\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\nimport {TableColumn} from \"../../schema-builder/table/TableColumn\";\nimport {Table} from \"../../schema-builder/table/Table\";\nimport {TableForeignKey} from \"../../schema-builder/table/TableForeignKey\";\nimport {TableIndex} from \"../../schema-builder/table/TableIndex\";\nimport {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport {SpannerDriver, SpannerColumnUpdateWithCommitTimestamp} from \"./SpannerDriver\";\nimport {\n    SpannerExtendSchemas,\n    SpannerExtendColumnSchema,\n    SpannerExtendedColumnProps,\n    SpannerExtendedTableProps,\n    SpannerExtendedColumnPropsFromTableColumn,\n    SpannerExtendSchemaSources\n} from \"./SpannerRawTypes\";\nimport {SpannerDDLTransformer} from \"./SpannerDDLTransformer\";\nimport {ReadStream} from \"../../platform/PlatformTools\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {RandomGenerator} from \"../../util/RandomGenerator\";\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\nimport {TableUnique} from \"../../schema-builder/table/TableUnique\";\nimport {BaseQueryRunner} from \"../../query-runner/BaseQueryRunner\";\nimport {Broadcaster} from \"../../subscriber/Broadcaster\";\nimport {PromiseUtils} from \"../../index\";\nimport {TableCheck} from \"../../schema-builder/table/TableCheck\";\nimport {IsolationLevel} from \"../types/IsolationLevel\";\nimport {EntityManager} from \"../../entity-manager/EntityManager\";\nimport {QueryBuilder} from \"../../query-builder/QueryBuilder\";\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {TableExclusion} from \"../../schema-builder/table/TableExclusion\";\n\n/**\n * Runs queries on a single mysql database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner implements QueryRunner {\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SpannerDriver;\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * transaction if startsTransaction\n     */\n    protected tx: any;\n\n    /**\n     * disable ddl parser. from synchronization, actual spanner DDL generated,\n     * so no need to parse even if option specify to use it.\n     */\n    protected disableDDLParser: boolean;\n\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SpannerDriver) {\n        super();\n        this.driver = driver;\n        this.disableDDLParser = false;\n        this.connection = driver.connection;\n        this.broadcaster = new Broadcaster(this);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        if (!this.databaseConnection) {\n            return (async () => {\n                this.databaseConnection = await this.driver.getDatabaseHandle();\n            })();\n        }\n        return Promise.resolve(this.databaseConnection);\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Starts transaction on the current connection.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        if (!this.driver.enableTransaction) {\n            //console.log('startTransaction(ignored)');\n            return Promise.resolve();\n        }\n        //console.log('startTransaction');\n        if (this.isTransactionActive)\n            throw new TransactionAlreadyStartedError();\n\n        this.isTransactionActive = true;\n        return this.connect().then(async (db) => {\n            this.tx = (await this.databaseConnection.getTransaction({\n                //readOnly: true,\n                strong: !!isolationLevel\n            }))[0];\n        });\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    commitTransaction(): Promise<void> {\n        if (!this.driver.enableTransaction) {\n            //console.log('commitTransaction(ignored)');\n            return Promise.resolve();\n        }\n        //console.log('commitTransaction');\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        return new Promise((res, rej) => this.tx.commit((err: Error, _: any) => {\n            //console.log('commitTransaction cb', err, _);\n            if (err) { rej(err); }\n            else {\n                this.tx = null;\n                this.isTransactionActive = false;\n                res();\n            }\n        }));\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.driver.enableTransaction) {\n            //console.log('rollbackTransaction(ignored)');\n            return Promise.resolve();\n        }\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        await new Promise((res, rej) => this.tx.rollback((err: Error, _: any) => {\n            if (err) { rej(err); }\n            else {\n                this.tx = null;\n                this.isTransactionActive = false;\n                res();\n            }\n        }));\n    }\n\n    /**\n     * Run provided function in transaction.\n     * internally it may use start/commit Transaction.\n     * Error will be thrown if transaction start/commit will fails\n     */\n    async runInTransaction<T>(\n        runInTransaction: (tx: EntityManager) => Promise<T>,\n        isolationLevel?: IsolationLevel\n    ): Promise<T> {\n        return new Promise<T>((res, rej) => {\n            this.connect().then(async (db) => {\n                this.databaseConnection.runTransaction({\n                    // TODO: how specify these options?\n                    //readOnly: true,\n                    strong: !!isolationLevel\n                }, async (err: Error, tx: any) => {\n                    if (err) {\n                        rej(err);\n                        return;\n                    }\n                    this.tx = tx;\n                    this.isTransactionActive = true;\n                    const r = await runInTransaction(this.manager);\n                    tx.commit((err: Error, _: any) => {\n                        if (err) {\n                            rej(err)\n                        } else {\n                            this.tx = null;\n                            this.isTransactionActive = false;\n                            res(r);\n                        }\n                    });\n                });\n            });\n        });\n    }\n\n    /**\n     * Executes sql used special for schema build.\n     */\n    protected async executeQueries(upQueries: string|string[], downQueries: string|string[]): Promise<void> {\n        this.disableDDLParser = true;\n        await super.executeQueries(upQueries, downQueries);\n        this.disableDDLParser = false;\n    }\n\n    /**\n     * Executes a raw SQL query.\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        // handle administrative queries.\n        let m: RegExpMatchArray | null;\n        if ((m = query.match(/^\\s*(CREATE|DROP|ALTER)\\s+(.+)/))) {\n            return this.handleAdministrativeQuery(m[1], m);\n        } else if (!query.match(/^\\s*SELECT\\s+(.+)/)) {\n            throw new Error(`the query cannot handle by this function: ${query}`);\n        }\n\n        return new Promise(async (ok, fail) => {\n            try {\n                await this.connect();\n                const db = this.tx || this.databaseConnection;\n                parameters = parameters || [];\n                const [ params, types ] = parameters;\n                //console.log('query', query, params, types);\n                this.driver.connection.logger.logQuery(query, params, this);\n                const queryStartTime = +new Date();\n                db.run({sql: query, params, types, json:true}, (err: any, result: any) => {\n                    // log slow queries if maxQueryExecution time is set\n                    const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\n                    const queryEndTime = +new Date();\n                    const queryExecutionTime = queryEndTime - queryStartTime;\n                    //console.log('query time', queryExecutionTime, 'ms');\n                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)\n                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n\n                    if (err) {\n                        this.driver.connection.logger.logQueryError(err, query, parameters, this);\n                        fail(new QueryFailedError(query, parameters, err));\n                        return;\n                    }\n\n                    //console.log('query()', result);\n                    ok(result);\n                });\n\n            } catch (err) {\n                fail(err);\n            }\n        });\n    }\n\n    /**\n     * execute query. call from XXXQueryBuilder\n     */\n    queryByBuilder<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        const fmaps: { [key:string]:(qb:QueryBuilder<Entity>) => Promise<any>} = {\n            select: this.select,\n            insert: this.insert,\n            update: this.update,\n            delete: this.delete\n        };\n\n        return this.connect().then(() => {\n            return fmaps[qb.expressionMap.queryType].call(this, qb);\n        });\n    }\n\n    queryByBuilderAndParams<Entity>(qb: QueryBuilder<Entity>, sql:string, params?:any[]): Promise<any> {\n        return this.query(sql, params);\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(query: string, parameters?: any[], onEnd?: Function, onError?: Function): Promise<ReadStream> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        return new Promise(async (ok, fail) => {\n            try {\n                await this.connect();\n                const db = this.databaseConnection;\n                this.driver.connection.logger.logQuery(query, parameters, this);\n                parameters = parameters || [];\n                const [ params, types ] = parameters;\n                const stream = db.runStream({sql: query, params, types});\n                if (onEnd) stream.on(\"end\", onEnd);\n                if (onError) stream.on(\"error\", onError);\n                ok(stream);\n\n            } catch (err) {\n                fail(err);\n            }\n        });\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return this.driver.getDatabases();\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        throw new Error(`NYI: spanner: getSchemas`);\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        return this.connect().then(async () => {\n            const dbs = await this.driver.getDatabases();\n            return dbs.indexOf(database) >= 0;\n        });\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new Error(`NYI: spanner: hasSchema`);\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table|string): Promise<boolean> {\n        return this.connect().then(async () => {\n            const table = await this.driver.loadTables(tableOrName);\n            //console.log('hasTable', tableOrName, !!table[0]);\n            return !!table[0];\n        });\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(tableOrName: Table|string, column: TableColumn|string): Promise<boolean> {\n        return this.connect().then(async () => {\n            const tables = await this.driver.loadTables(tableOrName);\n            return !!tables[0].columns.find((c: TableColumn) => {\n                if (typeof column === 'string' && c.name == column) {\n                    return true;\n                } else if (column instanceof TableColumn && c.name == column.name) {\n                    return true;\n                }\n                return false;\n            });\n        });\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(database: string, ifNotExist?: boolean): Promise<void> {\n        const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \\`${database}\\`` : `CREATE DATABASE \\`${database}\\``;\n        const down = `DROP DATABASE \\`${database}\\``;\n        await this.executeQueries(up, down);\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist ? `DROP DATABASE IF EXISTS \\`${database}\\`` : `DROP DATABASE \\`${database}\\``;\n        const down = `CREATE DATABASE \\`${database}\\``;\n        await this.executeQueries(up, down);\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(schema: string, ifNotExist?: boolean): Promise<void> {\n        throw new Error(`NYI: spanner: createSchema`);\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        throw new Error(`NYI: spanner: dropSchema`);\n    }\n\n    /**\n     * Creates a new table. aka 'schema' on spanner\n     * note that foreign key always dropped regardless the value of createForeignKeys.\n     * because our foreignkey analogue is achieved by interleaved table\n     */\n    async createTable(table: Table, ifNotExist: boolean = false, createForeignKeys: boolean = true): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table);\n            if (isTableExist) return Promise.resolve();\n        }\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n\n        // create table sql.\n        upQueries.push(this.createTableSql(table));\n        downQueries.push(this.dropTableSql(table));\n\n        console.log('createTable', `sql=[${upQueries[0]}]`);\n\n        // create indexes. unique constraint will be integrated with unique index.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach(unique => {\n                const uniqueExist = table.indices.some(index => index.name === unique.name);\n                if (!uniqueExist) {\n                    table.indices.push(new TableIndex({\n                        name: unique.name,\n                        columnNames: unique.columnNames,\n                        isUnique: true\n                    }));\n                }\n            });\n        }\n\n        if (table.indices.length > 0) {\n            table.indices.forEach(index => {\n                upQueries.push(this.createIndexSql(table, index));\n                downQueries.push(this.dropIndexSql(table, index));\n            });\n        }\n\n        // we don't drop foreign key itself. because its created with table\n        // if (createForeignKeys)\n        // table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n\n        await this.executeQueries(upQueries, downQueries);\n\n        // super.replaceCachedTable will be ignored because new table should not be loaded before.\n        this.replaceCachedTable(table, table);\n\n    }\n\n    /**\n     * Drop the table.\n     * note that foreign key always dropped regardless the value of dropForeignKeys.\n     * because our foreignkey analogue is achieved by interleaved table\n     */\n    async dropTable(target: Table|string, ifExist?: boolean, dropForeignKeys: boolean = true): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target);\n            if (!isTableExist) return Promise.resolve();\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        // const createForeignKeys: boolean = dropForeignKeys;\n        const tableName = target instanceof Table ? target.name : target;\n        const table = await this.getCachedTable(tableName);\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n\n        // if (dropForeignKeys)\n        // table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n\n        if (table.indices.length > 0) {\n            table.indices.forEach(index => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            });\n        }\n\n        upQueries.push(this.dropTableSql(table));\n        downQueries.push(this.createTableSql(table));\n\n        await this.executeQueries(upQueries, downQueries);\n\n        // remove table from cache\n        this.replaceCachedTable(table, null);\n    }\n\n    /**\n     * Renames a table.\n     */\n    async renameTable(oldTableOrName: Table|string, newTableName: string): Promise<void> {\n        // TODO: re-create table\n        throw new Error(`NYI: spanner: renameTable`);\n\n        /*const upQueries: string[] = [];\n        const downQueries: string[] = [];\n        const oldTable = oldTableOrName instanceof Table ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n        const newTable = oldTable.clone();\n        const dbName = oldTable.name.indexOf(\".\") === -1 ? undefined : oldTable.name.split(\".\")[0];\n        newTable.name = dbName ? `${dbName}.${newTableName}` : newTableName;\n\n        // rename table\n        upQueries.push(`RENAME TABLE ${this.escapeTableName(oldTable.name)} TO ${this.escapeTableName(newTable.name)}`);\n        downQueries.push(`RENAME TABLE ${this.escapeTableName(newTable.name)} TO ${this.escapeTableName(oldTable.name)}`);\n\n        // rename index constraints\n        newTable.indices.forEach(index => {\n            // build new constraint name\n            const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n\n            // build queries\n            let indexType = \"\";\n            if (index.isUnique)\n                indexType += \"UNIQUE \";\n            if (index.isSpatial)\n                indexType += \"SPATIAL \";\n            if (index.isFulltext)\n                indexType += \"FULLTEXT \";\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(newTable)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(newTable)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`);\n\n            // replace constraint name\n            index.name = newIndexName;\n        });\n\n        // rename foreign key constraint\n        newTable.foreignKeys.forEach(foreignKey => {\n            // build new constraint name\n            const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n            const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames);\n\n            // build queries\n            let up = `ALTER TABLE ${this.escapeTableName(newTable)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapeTableName(foreignKey.referencedTableName)}(${referencedColumnNames})`;\n            if (foreignKey.onDelete)\n                up += ` ON DELETE ${foreignKey.onDelete}`;\n            if (foreignKey.onUpdate)\n                up += ` ON UPDATE ${foreignKey.onUpdate}`;\n\n            let down = `ALTER TABLE ${this.escapeTableName(newTable)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapeTableName(foreignKey.referencedTableName)}(${referencedColumnNames})`;\n            if (foreignKey.onDelete)\n                down += ` ON DELETE ${foreignKey.onDelete}`;\n            if (foreignKey.onUpdate)\n                down += ` ON UPDATE ${foreignKey.onUpdate}`;\n\n            upQueries.push(up);\n            downQueries.push(down);\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName;\n        });\n\n        await this.executeQueries(upQueries, downQueries);\n\n        // rename old table and replace it in cached tabled;\n        oldTable.name = newTable.name;\n        this.replaceCachedTable(oldTable, newTable);*/\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(tableOrName: Table|string, column: TableColumn): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;\n\n        upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`);\n        downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP COLUMN \\`${column.name}\\``);\n\n        // create or update primary key constraint\n        if (column.isPrimary) {\n            // TODO: re-create table\n            throw new Error(`NYI: spanner: addColumn column.isPrimary`);\n            /*\n            // if we already have generated column, we must temporary drop AUTO_INCREMENT property.\n            const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone();\n                nonGeneratedColumn.isGenerated = false;\n                nonGeneratedColumn.generationStrategy = undefined;\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`);\n            }\n\n            const primaryColumns = clonedTable.primaryColumns;\n            let columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n\n            primaryColumns.push(column);\n            columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n\n            // if we previously dropped AUTO_INCREMENT property, we must bring it back\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone();\n                nonGeneratedColumn.isGenerated = false;\n                nonGeneratedColumn.generationStrategy = undefined;\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n            }\n            */\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex));\n            downQueries.push(this.dropIndexSql(table, columnIndex));\n\n        } else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table.name, [column.name]),\n                columnNames: [column.name],\n                isUnique: true\n            });\n            clonedTable.indices.push(uniqueIndex);\n            clonedTable.uniques.push(new TableUnique({\n                name: uniqueIndex.name,\n                columnNames: uniqueIndex.columnNames\n            }));\n            upQueries.push(this.createIndexSql(table, uniqueIndex));\n            downQueries.push(this.dropIndexSql(table, uniqueIndex));\n        }\n\n        await this.executeQueries(upQueries, downQueries);\n\n        clonedTable.addColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        await PromiseUtils.runInSequence(columns, column => this.addColumn(tableOrName, column));\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(tableOrName: Table|string, oldTableColumnOrName: TableColumn|string, newTableColumnOrName: TableColumn|string): Promise<void> {\n        throw new Error(`NYI: spanner: renameColumn. you can remove column first, then create with the same name.`);\n        /*\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new Error(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n        let newColumn: TableColumn|undefined = undefined;\n        if (newTableColumnOrName instanceof TableColumn) {\n            newColumn = newTableColumnOrName;\n        } else {\n            newColumn = oldColumn.clone();\n            newColumn.name = newTableColumnOrName;\n        }\n\n        await this.changeColumn(table, oldColumn, newColumn);\n        */\n    }\n\n    /**\n     * Changes a column in the table.\n     * according to https://cloud.google.com/spanner/docs/schema-updates, only below are allowed\n     * - Change a STRING column to a BYTES column or a BYTES column to a STRING column.\n     * - Increase or decrease the length limit for a STRING or BYTES type (including to MAX), unless it is a primary key column inherited by one or more child tables.\n     * - Add/Remove NOT NULL constraint for non-key column\n     * - Enable or disable commit timestamps in value and primary key columns.\n     */\n    async changeColumn(tableOrName: Table|string, oldColumnOrName: TableColumn|string, newColumn: TableColumn): Promise<void> {\n        //TODO: implement above changes in comment\n\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        let clonedTable = table.clone();\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n\n        const oldColumn = oldColumnOrName instanceof TableColumn\n            ? oldColumnOrName\n            : table.columns.find(column => column.name === oldColumnOrName);\n        if (!oldColumn)\n            throw new Error(`Column \"${oldColumnOrName}\" was not found in the \"${table.name}\" table.`);\n\n        if (oldColumn.name !== newColumn.name) {\n            throw new Error(`NYI: spanner: changeColumn: change column name ${oldColumn.name} => ${newColumn.name}`);\n        }\n\n        if (oldColumn.type !== newColumn.type) {\n            // - Change a STRING column to a BYTES column or a BYTES column to a STRING column.\n            if (!(oldColumn.type === \"string\" && newColumn.type === \"bytes\") &&\n                !(oldColumn.type === \"bytes\" && newColumn.type === \"string\")) {\n                throw new Error(`NYI: spanner: changeColumn: change column type ${oldColumn.type} => ${newColumn.type}`);\n            }\n        }\n\n        if (oldColumn.length && newColumn.length && (oldColumn.length !== newColumn.length)) {\n            // - Increase or decrease the length limit for a STRING or BYTES type (including to MAX)\n            if (!(oldColumn.type === \"string\" && newColumn.type === \"bytes\") &&\n                !(oldColumn.type === \"bytes\" && newColumn.type === \"string\")) {\n                throw new Error(`NYI: spanner: changeColumn: change column type ${oldColumn.type} => ${newColumn.type}`);\n            }\n            // TODO: implement following check.\n            // `unless it is a primary key column inherited by one or more child tables.`\n        }\n\n        if (oldColumn.isNullable !== newColumn.isNullable) {\n            // - Add/Remove NOT NULL constraint for non-key column\n            if (clonedTable.indices.find(index => {\n                return index.columnNames.length === 1 && index.columnNames[0] === newColumn.name;\n            })) {\n                throw new Error(`NYI: spanner: changeColumn: change nullable for ${oldColumn.name}, which is indexed`);\n            }\n        }\n\n        // - Enable or disable commit timestamps in value and primary key columns.\n        if (oldColumn.default !== newColumn.default) {\n            if (newColumn.default !== SpannerColumnUpdateWithCommitTimestamp &&\n                oldColumn.default !== SpannerColumnUpdateWithCommitTimestamp) {\n                throw new Error(`NYI: spanner: changeColumn: set default ${typeof oldColumn.default} => ${typeof newColumn.default}`);\n\n            }\n        }\n\n        // any other invalid changes\n        if (oldColumn.isPrimary !== newColumn.isPrimary ||\n            oldColumn.asExpression !== newColumn.asExpression ||\n            oldColumn.charset !== newColumn.charset ||\n            oldColumn.collation !== newColumn.collation ||\n            // comment is not supported by spanner\n            // default is managed by schemas table.\n            oldColumn.enum !== newColumn.enum ||\n            oldColumn.generatedType !== newColumn.generatedType ||\n            // generationStorategy is managed by schemas table\n            oldColumn.isArray !== newColumn.isArray\n            // isGenerated is managed by schemas table\n        ) {\n            throw new Error(`NYI: spanner: changeColumn: not supported change ${JSON.stringify(oldColumn)} => ${JSON.stringify(newColumn)}`);\n        }\n\n        // if actually changed, store SQLs\n        if (this.isColumnChanged(oldColumn, newColumn, true)) {\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ALTER COLUMN \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(newColumn, true)}`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ALTER COLUMN \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true)}`);\n        }\n\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(table, clonedTable);\n\n\n        /*\n        if ((newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== \"uuid\")\n            || oldColumn.type !== newColumn.type\n            || oldColumn.length !== newColumn.length\n            || oldColumn.generatedType !== newColumn.generatedType) {\n            await this.dropColumn(table, oldColumn);\n            await this.addColumn(table, newColumn);\n\n            // update cloned table\n            clonedTable = table.clone();\n\n        } else {\n            if (newColumn.name !== oldColumn.name) {\n                // We don't change any column properties, just rename it.\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${oldColumn.name}\\` \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${newColumn.name}\\` \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`);\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach(index => {\n                    // build new constraint name\n                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n                    index.columnNames.push(newColumn.name);\n                    const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n\n                    // build queries\n                    let indexType = \"\";\n                    if (index.isUnique)\n                        indexType += \"UNIQUE \";\n                    if (index.isSpatial)\n                        indexType += \"SPATIAL \";\n                    if (index.isFulltext)\n                        indexType += \"FULLTEXT \";\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`);\n\n                    // replace constraint name\n                    index.name = newIndexName;\n                });\n\n                // rename foreign key constraints\n                clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n                    // build new constraint name\n                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n                    foreignKey.columnNames.push(newColumn.name);\n                    const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n                    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames);\n\n                    // build queries\n                    let up = `ALTER TABLE ${this.escapeTableName(table)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                        `REFERENCES ${this.escapeTableName(foreignKey.referencedTableName)}(${referencedColumnNames})`;\n                    if (foreignKey.onDelete)\n                        up += ` ON DELETE ${foreignKey.onDelete}`;\n                    if (foreignKey.onUpdate)\n                        up += ` ON UPDATE ${foreignKey.onUpdate}`;\n\n                    let down = `ALTER TABLE ${this.escapeTableName(table)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` +\n                        `REFERENCES ${this.escapeTableName(foreignKey.referencedTableName)}(${referencedColumnNames})`;\n                    if (foreignKey.onDelete)\n                        down += ` ON DELETE ${foreignKey.onDelete}`;\n                    if (foreignKey.onUpdate)\n                        down += ` ON UPDATE ${foreignKey.onUpdate}`;\n\n                    upQueries.push(up);\n                    downQueries.push(down);\n\n                    // replace constraint name\n                    foreignKey.name = newForeignKeyName;\n                });\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn!)].name = newColumn.name;\n                oldColumn.name = newColumn.name;\n            }\n\n            if (this.isColumnChanged(oldColumn, newColumn, true)) {\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(newColumn, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true)}`);\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n                const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone();\n                    nonGeneratedColumn.isGenerated = false;\n                    nonGeneratedColumn.generationStrategy = undefined;\n\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`);\n                }\n\n                const primaryColumns = clonedTable.primaryColumns;\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn);\n                    // update column in table\n                    const column = clonedTable.columns.find(column => column.name === newColumn.name);\n                    column!.isPrimary = true;\n                    const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n\n                } else {\n                    const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn!), 1);\n                    // update column in table\n                    const column = clonedTable.columns.find(column => column.name === newColumn.name);\n                    column!.isPrimary = false;\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n                        upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n                        downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n                    }\n                }\n\n                // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone();\n                    nonGeneratedColumn.isGenerated = false;\n                    nonGeneratedColumn.generationStrategy = undefined;\n\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table.name, [newColumn.name]),\n                        columnNames: [newColumn.name],\n                        isUnique: true\n                    });\n                    clonedTable.indices.push(uniqueIndex);\n                    clonedTable.uniques.push(new TableUnique({\n                        name: uniqueIndex.name,\n                        columnNames: uniqueIndex.columnNames\n                    }));\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${newColumn.name}\\`)`);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP INDEX \\`${uniqueIndex.name}\\``);\n\n                } else {\n                    const uniqueIndex = clonedTable.indices.find(index => {\n                        return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n                    });\n                    clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex!), 1);\n\n                    const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex!.name);\n                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique!), 1);\n\n                    upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP INDEX \\`${uniqueIndex!.name}\\``);\n                    downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD UNIQUE INDEX \\`${uniqueIndex!.name}\\` (\\`${newColumn.name}\\`)`);\n                }\n            }\n        } */\n\n        // await this.executeQueries(upQueries, downQueries);\n        // this.replaceCachedTable(table, clonedTable);\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(tableOrName: Table|string, changedColumns: { newColumn: TableColumn, oldColumn: TableColumn }[]): Promise<void> {\n        await PromiseUtils.runInSequence(changedColumns, changedColumn => this.changeColumn(tableOrName, changedColumn.oldColumn, changedColumn.newColumn));\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(tableOrName: Table|string, columnOrName: TableColumn|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n        if (!column)\n            throw new Error(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n\n        const clonedTable = table.clone();\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            throw new Error(`NYI: spanner: dropColumn column.isPrimary`);\n            /*\n            // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n            const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone();\n                nonGeneratedColumn.isGenerated = false;\n                nonGeneratedColumn.generationStrategy = undefined;\n\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`);\n            }\n\n            // dropping primary key constraint\n            const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(clonedTable)} DROP PRIMARY KEY`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(clonedTable)} ADD PRIMARY KEY (${columnNames})`);\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name);\n            tableColumn!.isPrimary = false;\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(clonedTable)} ADD PRIMARY KEY (${columnNames})`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(clonedTable)} DROP PRIMARY KEY`);\n            }\n\n            // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back\n            if (generatedColumn && generatedColumn.name !== column.name) {\n                const nonGeneratedColumn = generatedColumn.clone();\n                nonGeneratedColumn.isGenerated = false;\n                nonGeneratedColumn.generationStrategy = undefined;\n\n                upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`);\n                downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n            }\n            */\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n        if (columnIndex) {\n            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n            upQueries.push(this.dropIndexSql(table, columnIndex));\n            downQueries.push(this.createIndexSql(table, columnIndex));\n\n        } else if (column.isUnique) {\n            // we splice constraints both from table uniques and indices.\n            const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table.name, [column.name]);\n            const foundUnique = clonedTable.uniques.find(unique => unique.name === uniqueName);\n            if (foundUnique)\n                clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);\n\n            const indexName = this.connection.namingStrategy.indexName(table.name, [column.name]);\n            const foundIndex = clonedTable.indices.find(index => index.name === indexName);\n            if (foundIndex) {\n                clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);\n                upQueries.push(this.dropIndexSql(table, foundIndex));\n                downQueries.push(this.createIndexSql(table, foundIndex));\n            }\n        }\n\n        upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP COLUMN \\`${column.name}\\``);\n        downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD ${this.buildCreateColumnSql(column, true)}`);\n\n        await this.executeQueries(upQueries, downQueries);\n\n        clonedTable.removeColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        await PromiseUtils.runInSequence(columns, column => this.dropColumn(tableOrName, column));\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(tableOrName: Table|string, columnNames: string[]): Promise<void> {\n        throw new Error(`NYI: spanner: createPrimaryKey`);\n\n        /*\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n\n        const up = this.createPrimaryKeySql(table, columnNames);\n        const down = this.dropPrimaryKeySql(table);\n\n        await this.executeQueries(up, down);\n        clonedTable.columns.forEach(column => {\n            if (columnNames.find(columnName => columnName === column.name))\n                column.isPrimary = true;\n        });\n        this.replaceCachedTable(table, clonedTable);\n        */\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(tableOrName: Table|string, columns: TableColumn[]): Promise<void> {\n        throw new Error(`NYI: spanner: updatePrimaryKeys`);\n        /*\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const columnNames = columns.map(column => column.name);\n        const upQueries: string[] = [];\n        const downQueries: string[] = [];\n\n        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n        const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n        if (generatedColumn) {\n            const nonGeneratedColumn = generatedColumn.clone();\n            nonGeneratedColumn.isGenerated = false;\n            nonGeneratedColumn.generationStrategy = undefined;\n\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`);\n        }\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns;\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNames})`);\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter(column => columnNames.indexOf(column.name) !== -1)\n            .forEach(column => column.isPrimary = true);\n\n        const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNamesString})`);\n        downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`);\n\n        // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back\n        const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n        if (newOrExistGeneratedColumn) {\n            const nonGeneratedColumn = newOrExistGeneratedColumn.clone();\n            nonGeneratedColumn.isGenerated = false;\n            nonGeneratedColumn.generationStrategy = undefined;\n\n            upQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`);\n            downQueries.push(`ALTER TABLE ${this.escapeTableName(table)} CHANGE \\`${newOrExistGeneratedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`);\n\n            // if column changed to generated, we must update it in table\n            const changedGeneratedColumn = clonedTable.columns.find(column => column.name === newOrExistGeneratedColumn.name);\n            changedGeneratedColumn!.isGenerated = true;\n            changedGeneratedColumn!.generationStrategy = \"increment\";\n        }\n\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(table, clonedTable);\n        */\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table|string): Promise<void> {\n        throw new Error(`NYI: spanner: dropPrimaryKey`);\n        /*\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const up = this.dropPrimaryKeySql(table);\n        const down = this.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name));\n        await this.executeQueries(up, down);\n        table.primaryColumns.forEach(column => {\n            column.isPrimary = false;\n        });\n        */\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(tableOrName: Table|string, uniqueConstraint: TableUnique): Promise<void> {\n        throw new Error(`NYI: spanner: createUniqueConstraint`);\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(tableOrName: Table|string, uniqueConstraints: TableUnique[]): Promise<void> {\n        throw new Error(`NYI: spanner: createUniqueConstraints`);\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(tableOrName: Table|string, uniqueOrName: TableUnique|string): Promise<void> {\n        throw new Error(`NYI: spanner: dropUniqueConstraint`);\n    }\n\n    /**\n     * Drops an unique constraints.\n     */\n    async dropUniqueConstraints(tableOrName: Table|string, uniqueConstraints: TableUnique[]): Promise<void> {\n        throw new Error(`NYI: spanner: dropUniqueConstraints`);\n    }\n\n    /**\n     * Creates a new check constraint.\n     */\n    async createCheckConstraint(tableOrName: Table|string, checkConstraint: TableCheck): Promise<void> {\n        throw new Error(`NYI: spanner: createCheckConstraint`);\n    }\n\n    /**\n     * Creates a new check constraints.\n     */\n    async createCheckConstraints(tableOrName: Table|string, checkConstraints: TableCheck[]): Promise<void> {\n        throw new Error(`NYI: spanner: createCheckConstraints`);\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(tableOrName: Table|string, checkOrName: TableCheck|string): Promise<void> {\n        throw new Error(`NYI: spanner: dropCheckConstraint`);\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(tableOrName: Table|string, checkConstraints: TableCheck[]): Promise<void> {\n        throw new Error(`NYI: spanner: dropCheckConstraints`);\n    }\n\n    /**\n     * Creates a new foreign key. in spanner, it creates corresponding index too\n     */\n    async createForeignKey(tableOrName: Table|string, foreignKey: TableForeignKey): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table.name, foreignKey.columnNames);\n\n        const up = this.createForeignKeySql(table, foreignKey);\n        const down = this.dropForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.addForeignKey(foreignKey);\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(tableOrName: Table|string, foreignKeys: TableForeignKey[]): Promise<void> {\n        // in spanner, we achieve foreign key analogue with interleaved table.\n        // const promises = foreignKeys.map(foreignKey => this.createForeignKey(tableOrName, foreignKey));\n        // await Promise.all(promises);\n    }\n\n    /**\n     * Drops a foreign key.\n     */\n    async dropForeignKey(tableOrName: Table|string, foreignKeyOrName: TableForeignKey|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n        if (!foreignKey)\n            throw new Error(`Supplied foreign key was not found in table ${table.name}`);\n\n        const up = this.dropForeignKeySql(table, foreignKey);\n        const down = this.createForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.removeForeignKey(foreignKey);\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(tableOrName: Table|string, foreignKeys: TableForeignKey[]): Promise<void> {\n        const promises = foreignKeys.map(foreignKey => this.dropForeignKey(tableOrName, foreignKey));\n        await Promise.all(promises);\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(tableOrName: Table|string, index: TableIndex): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.connection.namingStrategy.indexName(table.name, index.columnNames, index.where);\n\n        const up = this.createIndexSql(table, index);\n        const down = this.dropIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.addIndex(index, true);\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(tableOrName: Table|string, indices: TableIndex[]): Promise<void> {\n        const promises = indices.map(index => this.createIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n\n    /**\n     * Drops an index.\n     */\n    async dropIndex(tableOrName: Table|string, indexOrName: TableIndex|string): Promise<void> {\n        const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n        const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(i => i.name === indexOrName);\n        if (!index)\n            throw new Error(`Supplied index was not found in table ${table.name}`);\n\n        const up = this.dropIndexSql(table, index);\n        const down = this.createIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.removeIndex(index, true);\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(tableOrName: Table|string, indices: TableIndex[]): Promise<void> {\n        const promises = indices.map(index => this.dropIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableOrName: Table|string): Promise<void> {\n        if (tableOrName instanceof Table) {\n            tableOrName = tableOrName.name;\n        }\n        const qb = this.connection.manager\n            .createQueryBuilder(this)\n            .delete()\n            .from(tableOrName);\n        return await this.delete(qb);\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     * Be careful using this method and avoid using it in production or migrations\n     * (because it can clear all your database).\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        const tables = await this.driver.getAllTablesForDrop(true);\n        const keys = Object.keys(tables);\n        const CONCURRENT_DELETION = 10;\n        for (let i = 0; i < Math.ceil(keys.length / CONCURRENT_DELETION); i++) {\n            const start = i * CONCURRENT_DELETION;\n            const end = (i + 1) * CONCURRENT_DELETION;\n            const range = keys.slice(start, end);\n            if (range.length <= 0) {\n                break;\n            }\n            await Promise.all(range.map(async (k) => {\n                return this.dropTable(k);\n            }));\n        }\n        /*const dbName = database ? database : this.driver.database;\n        if (dbName) {\n            const isDatabaseExist = await this.hasDatabase(dbName);\n            if (!isDatabaseExist)\n                return Promise.resolve();\n        } else {\n            throw new Error(`Can not clear database. No database is specified`);\n        }\n\n        await this.startTransaction();\n        try {\n            const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;\n            const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`;\n            const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;\n\n            await this.query(disableForeignKeysCheckQuery);\n            const dropQueries: ObjectLiteral[] = await this.query(dropTablesQuery);\n            await Promise.all(dropQueries.map(query => this.query(query[\"query\"])));\n            await this.query(enableForeignKeysCheckQuery);\n\n            await this.commitTransaction();\n\n        } catch (error) {\n            try { // we throw original error even if rollback thrown an error\n                await this.rollbackTransaction();\n            } catch (rollbackError) { }\n            throw error;\n        }*/\n    }\n\n    /**\n     * create `schemas` table which describe additional column information such as\n     * generated column's increment strategy or default value\n     * @database: spanner's database object.\n     */\n    async createAndLoadSchemaTable(tableName: string): Promise<SpannerExtendSchemas> {\n        const tableExist = await this.hasTable(tableName); // todo: table name should be configurable\n        if (!tableExist) {\n            await this.createTable(new Table(\n                {\n                    name: tableName,\n                    columns: [\n                        {\n                            name: \"table\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationName}),\n                            isPrimary: true,\n                            isNullable: false\n                        },\n                        {\n                            name: \"column\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationName}),\n                            isPrimary: true,\n                            isNullable: false\n                        },\n                        {\n                            name: \"type\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationName}),\n                            isPrimary: true,\n                            isNullable: false\n                        },\n                        {\n                            name: \"value\",\n                            type: this.connection.driver.normalizeType({type: this.connection.driver.mappedDataTypes.migrationName}),\n                            isNullable: false\n                        },\n                    ]\n                },\n            ));\n        }\n\n        const rawObjects: ObjectLiteral[] = await this.loadExtendSchemaTable(tableName);\n\n        const schemas: SpannerExtendSchemas = {};\n        for (const rawObject of rawObjects) {\n            const table = rawObject[\"table\"];\n            if (!schemas[table]) {\n                schemas[table] = {};\n            }\n            const tableSchemas = schemas[table];\n            const column = rawObject[\"column\"];\n            if (!tableSchemas[column]) {\n                tableSchemas[column] = {};\n            }\n            // value is stored in data as JSON.stringify form\n            Object.assign(tableSchemas[column], this.createExtendSchemaObject(\n                table, rawObject[\"type\"], rawObject[\"value\"]));\n        }\n\n        return schemas;\n    }\n\n\n    /**\n     * Synchronizes table extend schema.\n     * systemTables means internally used table, such as migrations.\n     */\n    public async syncExtendSchemas(metadata: EntityMetadata[]): Promise<SpannerExtendSchemas> {\n        // specify true, to update `tables` to latest schema definition automatically\n        const allSchemaObjects: { [k:string]:ObjectLiteral[] } = {};\n        const raw = await this.loadExtendSchemaTable(\n            this.driver.getSchemaTableName()\n        );\n        const systemTables = await this.driver.getSystemTables();\n        raw.forEach((o) => {\n            const t = o[\"table\"];\n            if (!allSchemaObjects[t]) {\n                allSchemaObjects[t] = [];\n            }\n            allSchemaObjects[t].push(o);\n        });\n        const tableProps = (<SpannerExtendedTableProps[]>metadata)\n        .concat(systemTables.map((st) => {\n            return {\n                name: st.name,\n                columns: st.columns.map((c) => {\n                    return new SpannerExtendedColumnPropsFromTableColumn(c);\n                })\n            }\n        }));\n        const oldNormalTables = Object.keys(allSchemaObjects);\n        const newExtendSchemas: SpannerExtendSchemas = {};\n        await Promise.all(tableProps.map(async (t) => {\n            const oldTableIndex = oldNormalTables.indexOf(t.name);\n            if (oldTableIndex >= 0) {\n                oldNormalTables.splice(oldTableIndex, 1);\n            }\n            const promises: Promise<void[]>[] = [];\n            const schemaObjectsByTable = allSchemaObjects[t.name] || [];\n            const oldColumns = schemaObjectsByTable.map(o => o[\"column\"]);\n            for (const c of t.columns) {\n                const oldColumnIndex = oldColumns.indexOf(c.databaseName);\n                if (oldColumnIndex >= 0) {\n                    oldColumns.splice(oldColumnIndex, 1);\n                }\n                //add, remove is not json stringified.\n                const { add, remove } = this.getSyncExtendSchemaObjects(t, c);\n                const addFiltered = add.filter((e) => {\n                    // filter element which already added and not changed\n                    return !schemaObjectsByTable.find(\n                        (o) => o[\"column\"] === e.column &&\n                            o[\"type\"] === e.type &&\n                            o[\"value\"] === e.value\n                    );\n                });\n                const removeFiltered = remove.filter((e) => {\n                    // filter element which does not exist\n                    return schemaObjectsByTable.find(\n                        (o) => o[\"column\"] === e.column && o[\"type\"] === e.type\n                    );\n                });\n                if ((addFiltered.length + removeFiltered.length) > 0) {\n                    promises.push(Promise.all([\n                        ...addFiltered.map((e) => this.upsertExtendSchema(e.table, e.column, e.type, e.value)),\n                        ...removeFiltered.map((e) => this.deleteExtendSchema(e.table, e.column, e.type))\n                    ]));\n                }\n                if (add.length > 0) {\n                    if (!newExtendSchemas[t.name]) {\n                        newExtendSchemas[t.name] = {}\n                    }\n                    for (const a of add) {\n                        newExtendSchemas[t.name][c.databaseName] = this.createExtendSchemaObject(\n                            a.table, a.type, a.value\n                        );\n                    }\n                }\n            }\n            // if column is no more exists in new entity metadata, remove all extend schema for such columns\n            if (oldColumns.length > 0) {\n                console.log('oldColumns', oldColumns);\n                promises.push(Promise.all(oldColumns.map(async c => {\n                    await this.deleteExtendSchema(t.name, c);\n                })));\n            }\n            if (promises.length > 0) {\n                await Promise.all(promises);\n            }\n        }));\n        if (oldNormalTables.length > 0) {\n            //console.log('oldNormalTables', oldNormalTables);\n            await Promise.all(oldNormalTables.map(async (tableName) => {\n                await this.deleteExtendSchema(tableName);\n            }));\n        }\n        return newExtendSchemas;\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(table: Table|string, exclusionConstraint: TableExclusion): Promise<void> {\n        throw new Error(`MySql does not support exclusion constraints.`);\n    }\n\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(table: Table|string, exclusionConstraints: TableExclusion[]): Promise<void> {\n        throw new Error(`MySql does not support exclusion constraints.`);\n    }\n\n    /**\n     * Drops a exclusion constraint.\n     */\n    async dropExclusionConstraint(table: Table|string, exclusionOrName: TableExclusion|string): Promise<void> {\n        throw new Error(`MySql does not support exclusion constraints.`);\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(table: Table|string, exclusionConstraints: TableExclusion[]): Promise<void> {\n        throw new Error(`MySql does not support exclusion constraints.`);\n    }\n\n\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * helper for createAndLoadSchemaTable.\n     * create schema object from schemas table column\n     * @param type\n     * @param value\n     */\n    protected createExtendSchemaObject(\n        table: string, type: string, value: string\n    ): SpannerExtendColumnSchema {\n        const columnSchema: SpannerExtendColumnSchema = {};\n        if (type === \"generator\") {\n            if (value == \"uuid\") {\n                columnSchema.generatorStorategy = \"uuid\";\n                columnSchema.generator = RandomGenerator.uuid4;\n            } else if (value == \"increment\") {\n                columnSchema.generatorStorategy = \"increment\";\n                // we automatically process increment generation storategy as uuid.\n                // because spanner strongly discourage auto increment column.\n                // TODO: if there is request, implement auto increment somehow.\n                if (table !== \"migrations\") {\n                    this.driver.connection.logger.log(\"warn\", \"column value generatorStorategy `increment` treated as `uuid` on spanner, due to performance reason.\");\n                }\n                columnSchema.generator = SpannerDriver.randomInt64;\n            }\n\n        } else if (type === \"default\") {\n            columnSchema.default = value;\n            columnSchema.generator = this.driver.decodeDefaultValueGenerator(value);\n\n        }\n\n        return columnSchema;\n    }\n\n    protected verifyAndFillAutoGeneratedValues(\n        table: Table,\n        valuesSet?: ObjectLiteral|ObjectLiteral[]\n    ): undefined|ObjectLiteral|ObjectLiteral[] {\n        if (!valuesSet) {\n            return valuesSet;\n        }\n        if (!(valuesSet instanceof Array)) {\n            valuesSet = [valuesSet];\n        }\n        for (const values of valuesSet) {\n            for (const column of table.columns) {\n                if (values[column.name] === undefined) {\n                    const value = this.driver.autoGenerateValue(table.name, column.name);\n                    if (value !== undefined) {\n                        values[column.name] = value;\n                    }\n                } else {\n                    values[column.name] = this.driver.normalizeValue(\n                        values[column.name], column.type);\n                }\n            }\n        }\n        return valuesSet;\n    }\n\n    protected verifyValues(\n        table: Table,\n        valuesSet?: ObjectLiteral|ObjectLiteral[]\n    ): undefined|ObjectLiteral|ObjectLiteral[] {\n        if (!valuesSet) {\n            return valuesSet;\n        }\n        if (!(valuesSet instanceof Array)) {\n            valuesSet = [valuesSet];\n        }\n        for (const values of valuesSet) {\n            for (const column of table.columns) {\n                if (values[column.name] !== undefined) {\n                    values[column.name] = this.driver.normalizeValue(\n                        values[column.name], column.type);\n                }\n            }\n        }\n        return valuesSet;\n    }\n\n    /**\n     * helper for createAndLoadSchemaTable.\n     * load formatted object from schema table\n     */\n    protected async loadExtendSchemaTable(tableName: string): Promise<ObjectLiteral[]> {\n        return await this.connection.manager\n            .createQueryBuilder(this)\n            .select()\n            .from(tableName, \"\")\n            .getRawMany();\n    }\n\n    /**\n     * get query string to examine select/update/upsert/delete keys.\n     * null means value contains all key elements already.\n     */\n    protected async examineKeys<Entity>(table: Table, qb: QueryBuilder<Entity>, keysOnly?: boolean): Promise<ObjectLiteral[]|any[]|null> {\n        /*\n            qbが\n            primary keyを含んでいる場合\n            primary keyのカラムが１つ\n            - qb.expressionMap.parameters.qb_ids or qb.whereExpressionのIN(...)の中身（パースの必要あり)\n            primary keyのカラムが２つ以上\n            - qb.expressionMap.nativeParametersの[\"id_\" + index1 + \"_\" + index2]みたいなところに格納されている\n\n            primary keyを完全には含まない場合\n            entityを使わないupdate/deleteクエリ. とりあえずエラーを吐くが、将来的にはqb.whereExpressionとqb.parametersを使って\n            下記のようなクエリを作りidを取得する.\n        */\n        const expressionMap = qb.expressionMap;\n        let m: RegExpMatchArray|null;\n        // check fast path\n        if (expressionMap.parameters.qb_ids) {\n            // non numeric single primary key\n            const pc = table.primaryColumns[0];\n            const keys = keysOnly ?\n                expressionMap.parameters.qb_ids :\n                (expressionMap.parameters.qb_ids as any[]).map(e => {\n                    return {\n                        [pc.name]: e\n                    };\n                });\n                this.driver.connection.logger.log(\"info\", `single primary key ${JSON.stringify(keys)}`);\n            return keys;\n        } else if (table.primaryColumns.length > 1) {\n            const keys: any[] = [];\n            for (const k of Object.keys(expressionMap.nativeParameters)) {\n                m = k.match(/id_([0-9]+)_([0-9]+)/);\n                if (m) {\n                    const idx1 = Number(m[1]);\n                    if (!keys[idx1]) {\n                        keys[idx1] = keysOnly ? [] : <ObjectLiteral>{};\n                    }\n                    const idx2 = Number(m[2]);\n                    if (keysOnly) {\n                        keys[idx1][idx2] = expressionMap.nativeParameters[k];\n                    } else {\n                        const pc = table.primaryColumns[idx2];\n                        keys[idx1][pc.name] = expressionMap.nativeParameters[k];\n                    }\n                }\n            }\n            if (keys.length > 0) {\n                this.driver.connection.logger.log(\"info\", `multiple primary keys ${JSON.stringify(keys)}`);\n                return keys;\n            }\n        }\n        const [query, parameters] = qb.getQueryAndParameters();\n        const [params, types] = parameters;\n        if (m = query.match(/IN\\(([^)]+)\\)/)) {\n            const pc = table.primaryColumns[0];\n            // parse IN statement (Number)\n            // TODO: descriminator column uses IN statement. what is descriminator column?\n            const parsed = m[1].split(\",\");\n            const keys = keysOnly ? parsed : parsed.map(e => {\n                return {\n                    [pc.name]: Number(e.trim())\n                };\n            });\n            this.driver.connection.logger.log(\"info\", `single numeric primary ${JSON.stringify(keys)}`);\n            return keys;\n        }\n        // not fast path. examine keys using where expression\n        const idx = query.indexOf(\"WHERE\");\n        const sql = (\n            `SELECT ${table.primaryColumns.map((c) => c.name).join(',')} FROM ${qb.escapedMainTableName}` +\n            (idx >= 0 ? query.substring(idx) : \"\")\n        );\n        // run is both promisified\n        const [results, err] = await (this.tx || this.databaseConnection).run({ sql, params, types, json:true });\n        if (err) {\n            this.driver.connection.logger.logQueryError(err, sql, [], this);\n            throw err;\n        }\n        if (!results || results.length <= 0) {\n            return [];\n        }\n        const keys = keysOnly ?\n            (table.primaryColumns.length > 1 ?\n                (results as ObjectLiteral[]).map(r => table.primaryColumns.map(pc => r[pc.name])) :\n                (results as ObjectLiteral[]).map(r => r[table.primaryColumns[0].name])\n            ) :\n            results;\n        this.driver.connection.logger.log(\"info\", `queried keys ${JSON.stringify(keys)} by ${query} ${!!this.tx}`);\n        return keys;\n    }\n\n    /**\n     * wrapper to integrate request by transaction and table\n     * connect() should be already called before this function invoked.\n     */\n    protected request(\n        table: Table,\n        method: \"insert\"|\"update\"|\"upsert\"|\"deleteRows\",\n        ...args: any[]\n    ): Promise<any> {\n        if (this.driver.connection.options.logging) {\n            this.driver.connection.logger.logQuery(\n                `${method} ${table.name} ${this.isTransactionActive ? \"tx\" : \"non-tx\"}`, args[0]\n            );\n        }\n        if (this.tx) {\n            return this.tx[method](table.name, ...args);\n        } else {\n            return this.databaseConnection.table(table.name)[method](...args);\n        }\n    }\n\n    /**\n     * Handle select query\n     */\n    protected select<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        const [query, parameters] = qb.getQueryAndParameters();\n        return this.query(query, parameters);\n    }\n\n    /**\n     * Handle insert query\n     */\n    protected insert<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        return new Promise(async (ok, fail) => {\n            try {\n                const table = await this.getTable(qb.mainTableName).catch(fail);\n                if (!table) {\n                    fail(new Error(`insert: fatal: no such table ${qb.mainTableName}`));\n                    return;\n                }\n                const vss = this.verifyAndFillAutoGeneratedValues(\n                    table, qb.expressionMap.valuesSet);\n                // NOTE: when transaction mode, callback (next args of vss) never called.\n                // at transaction mode, this call just change queuedMutations_ property of this.tx,\n                // and callback ignored.\n                // then actual mutation will be done when commitTransaction is called.\n                await this.request(table, 'insert', vss);\n                ok(vss);\n            } catch (e) {\n                fail(e);\n            }\n        });\n    }\n\n    /**\n     * Handle update query\n     */\n    protected update<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        return new Promise(async (ok, fail) => {\n            try {\n                const table = await this.getTable(qb.mainTableName).catch(fail);\n                if (!table) {\n                    fail(new Error(`update: fatal: no such table ${qb.mainTableName}`));\n                    return;\n                }\n                const vss = this.verifyValues(table, qb.expressionMap.valuesSet);\n                if (!vss || !(vss instanceof Array)) {\n                    fail(new Error('only single value set can be used spanner update'));\n                    return;\n                }\n                const value = <ObjectLiteral>vss[0]; //above vs checks assure this cast is valid\n                const rows = await this.examineKeys(table, qb).catch(fail);\n                if (rows === null) {\n                    ok();\n                    return;\n                }\n                for (const row of rows) {\n                    Object.assign(row, value);\n                }\n                // callback not provided see comment of insert\n                await this.request(table, 'update', rows);\n                ok(rows);\n            } catch (e) {\n                fail(e);\n            }\n        });\n    }\n\n    /**\n     * Handle upsert query\n     */\n    protected upsert<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        return new Promise(async (ok, fail) => {\n            try {\n                const table = await this.getTable(qb.mainTableName).catch(fail);\n                if (!table) {\n                    fail(new Error(`upsert: fatal: no such table ${qb.mainTableName}`));\n                    return;\n                }\n                // for upsert, we assume all primary keys are provided, like insert.\n                const vss = this.verifyAndFillAutoGeneratedValues(\n                    table, qb.expressionMap.valuesSet);\n                // callback not provided see comment of insert\n                await this.request(table, 'upsert', vss);\n                ok(vss);\n            } catch (e) {\n                fail(e);\n            }\n        });\n    }\n\n    /**\n     * Handle delete query\n     */\n    protected delete<Entity>(qb: QueryBuilder<Entity>): Promise<any> {\n        return new Promise(async (ok, fail) => {\n            try {\n                const table = await this.getTable(qb.mainTableName).catch(fail);\n                if (!table) {\n                    fail(new Error(`fatal: no such table ${qb.mainTableName}`));\n                    return;\n                }\n                const rows = await this.examineKeys(table, qb, true).catch(fail);\n                if (rows === null || (<any[]>rows).length <= 0) {\n                    ok();\n                    return;\n                }\n                // callback not provided see comment of insert\n                await this.request(table, 'deleteRows', rows);\n                ok();\n            } catch (e) {\n                fail(e);\n            }\n        });\n    }\n    /**\n     * unescape table/database name\n     */\n    protected unescapeName(name: string): string {\n        return name.replace(/`([^`]+)`/, \"$1\");\n    }\n\n    /**\n     * convert parsed non-spanner sql to spanner ddl string and extend schema.\n     * ast is generated by NearleyParser( = require('nearley').Parser)\n     */\n    protected toSpannerQueryAndSchema(ddl: string): [string, SpannerExtendSchemaSources, string] {\n        this.driver.ddlParser.resetParser();\n        const parser = this.driver.ddlParser.parser;\n        parser.feed(ddl);\n\n        const extendSchemas: SpannerExtendSchemaSources = {};\n        const t = new SpannerDDLTransformer(this.driver.encodeDefaultValueGenerator.bind(this.driver));\n        return [t.transform(parser.results[0], extendSchemas), extendSchemas, t.scopedTable];\n    }\n\n    /**\n     * Handle administrative sqls as spanner API call\n     */\n    protected handleAdministrativeQuery(type: string, m: RegExpMatchArray): Promise<any>{\n        return this.connect().then(async conn => {\n            if (type == \"CREATE\") {\n                const p = m[2].split(/\\s/);\n                if (p[0] == \"DATABASE\") {\n                    let name = this.unescapeName(p[1]);\n                    if (p[1] == \"IF\") {\n                        if (p[2] != \"NOT\") {\n                            return Promise.reject(new Error(`invalid query ${m[0]}`));\n                        } else {\n                            name = p[4];\n                        }\n                    }\n                    return this.driver.createDatabase(name);\n                }\n            } else if (type == \"DROP\") {\n                const p = m[2].split(/\\s/);\n                if (p[0] == \"DATABASE\") {\n                    let name = this.unescapeName(p[1]);\n                    if (p[1] == \"IF\") {\n                        if (p[2] != \"EXISTS\") {\n                            return Promise.reject(new Error(`invalid query ${m[0]}`));\n                        } else {\n                            name = p[3];\n                        }\n                    }\n                    return this.driver.dropDatabase(name);\n                } else if (p[0] == \"TABLE\") {\n                    let name = this.unescapeName(p[1]);\n                    return this.driver.dropTable(name);\n                }\n            }\n            //others all updateSchema\n            console.log('handleAdminQuery', m[0]);\n            let sqls = m[0];\n            if (!this.disableDDLParser && this.driver.ddlParser) {\n                const ddl = m[0][m[0].length - 1] === ';' ? m[0] : (m[0] + \";\");\n                let extendSchames: SpannerExtendSchemaSources = {};\n                [sqls, extendSchames] = this.toSpannerQueryAndSchema(ddl);\n                console.log('handleAdminQuery', sqls, extendSchames);\n                for (const tableName in extendSchames) {\n                    const table = extendSchames[tableName];\n                    for (const columnName in table) {\n                        const column = table[columnName];\n                        this.upsertExtendSchema(tableName, columnName, column.type, column.value);\n                    }\n                }\n            }\n            await Promise.all(\n                sqls.split(';').\n                filter(sql => !!sql).\n                map(sql => conn.updateSchema(sql).then((data: any[]) => {\n                    return data[0].promise();\n                }))\n            );\n        });\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (!tableNames || !tableNames.length)\n            return [];\n\n        return this.connect().then(async () => {\n            const tables = await this.driver.loadTables(tableNames);\n            return tables;\n        });\n    }\n\n    /**\n     * Builds create table sql\n     */\n    protected createTableSql(table: Table): string {\n        const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, true)).join(\", \");\n        let sql = `CREATE TABLE ${this.escapeTableName(table)} (${columnDefinitions}`;\n\n        // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter(column => column.isUnique)\n            .forEach(column => {\n                const isUniqueIndexExist = table.indices.some(index => {\n                    return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n                });\n                const isUniqueConstraintExist = table.uniques.some(unique => {\n                    return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n                });\n                if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                    table.indices.push(new TableIndex({\n                        name: this.connection.namingStrategy.uniqueConstraintName(table.name, [column.name]),\n                        columnNames: [column.name],\n                        isUnique: true\n                    }));\n            });\n\n        sql += `)`;\n\n        if (table.primaryColumns.length > 0) {\n            const columnNames = table.primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            sql += ` PRIMARY KEY (${columnNames})`;\n        }\n\n        if (table.foreignKeys.length > 0) {\n            const foreignKeysSql = table.foreignKeys.map(fk => {\n                let constraint = `INTERLEAVE IN PARENT ${this.escapeTableName(fk.referencedTableName)}`;\n                if (fk.onDelete)\n                    constraint += ` ON DELETE ${fk.onDelete}`;\n                if (fk.onUpdate)\n                    throw new Error(`NYI: spanner: fk.onUpdate`); //constraint += ` ON UPDATE ${fk.onUpdate}`;\n\n                return constraint;\n            }).join(\", \");\n\n            sql += `, ${foreignKeysSql}`;\n        }\n\n        //console.log('createTableSql', sql);\n\n        return sql;\n    }\n\n    /**\n     * Builds drop table sql\n     */\n    protected dropTableSql(tableOrName: Table|string): string {\n        return `DROP TABLE ${this.escapeTableName(tableOrName)}`;\n    }\n\n    protected async dropTableSqlRecursive(tableOrName: Table|string, upQueries: string[], downQueries: string[]): Promise<void> {\n        if (typeof tableOrName == 'string') {\n            const table = await this.getTable(tableOrName);\n            if (!table) {\n                return; // already deleted\n            }\n            tableOrName = table;\n        }\n        await Promise.all(tableOrName.foreignKeys.map((fk) => {\n            this.dropTableSqlRecursive(fk.referencedTableName, upQueries, downQueries);\n        }))\n        upQueries.push(this.dropTableSql(tableOrName));\n        downQueries.push(this.createTableSql(tableOrName));\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): string {\n        //TODO: somehow supports interleave and storing clause\n        const columns = index.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        let indexType = \"\";\n        if (index.isUnique)\n            indexType += \"UNIQUE \";\n        if (index.isSpatial)\n            indexType += \"NULL_FILTERED \";\n        if (index.isFulltext)\n            throw new Error(`NYI: spanner: index.isFulltext`); //indexType += \"FULLTEXT \";\n        return `CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapeTableName(table)}(${columns})`;\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(table: Table, indexOrName: TableIndex|string): string {\n        //throw new Error('should not drop any index');\n        let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n        return `DROP INDEX \\`${indexName}\\``;\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(table: Table, columnNames: string[]): string {\n        const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        return `ALTER TABLE ${this.escapeTableName(table)} ADD PRIMARY KEY (${columnNamesString})`;\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): string {\n        return `ALTER TABLE ${this.escapeTableName(table)} DROP PRIMARY KEY`;\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(table: Table, foreignKey: TableForeignKey): string {\n        throw new Error('NYI: spanner: column level foreign key declaration');\n        /* const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n        const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\",\");\n        const fkName = foreignKey.name || `${referencedColumnNames}By${foreignKey.columnNames.join()}`;\n        let sql = `CREATE INDEX ${fkName} ON\n            ${this.escapeTableName(table.name)}\\(${referencedColumnNames}, ${columnNames}\\)\n            INTERLEAVE IN ${this.escapeTableName(foreignKey.referencedTableName)}`;\n        if (foreignKey.onDelete)\n            sql += ` ON DELETE ${foreignKey.onDelete}`;\n        if (foreignKey.onUpdate)\n            throw new Error(`NYI: spanner: foreignKey.onUpdate`); //sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n\n        return sql; */\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(table: Table, foreignKeyOrName: TableForeignKey|string): string {\n        throw new Error('NYI: spanner: column level foreign key declaration');\n        /* const foreignKeyName = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;\n        return `DROP INDEX \\`${foreignKeyName}\\` ON ${this.escapeTableName(table)}`; */\n    }\n\n    protected parseTableName(target: Table|string) {\n        const tableName = target instanceof Table ? target.name : target;\n        return {\n            database: tableName.indexOf(\".\") !== -1 ? tableName.split(\".\")[0] : this.driver.database,\n            tableName: tableName.indexOf(\".\") !== -1 ? tableName.split(\".\")[1] : tableName\n        };\n    }\n\n    /**\n     * Escapes given table name.\n     */\n    protected escapeTableName(target: Table|string, disableEscape?: boolean): string {\n        const tableName = target instanceof Table ? target.name : target;\n        let splits = tableName.split(\".\");\n        if (splits.length > 1) {\n            //omit database name to avoid spanner table name parse error.\n            splits = splits.slice(1);\n        }\n        return splits.map(i => disableEscape ? i : `\\`${i}\\``).join(\".\");\n    }\n\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    protected buildCreateColumnSql(column: TableColumn, skipPrimary: boolean, skipName: boolean = false) {\n        let c = \"\";\n        if (skipName) {\n            c = this.connection.driver.createFullType(column);\n        } else {\n            c = `\\`${column.name}\\` ${this.connection.driver.createFullType(column)}`;\n        }\n        if (column.asExpression)\n            throw new Error(`NYI: spanner: column.asExpression`); // c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n\n        // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.\n        if (column.zerofill) {\n            throw new Error(`NYI: spanner: column.zerofill`); // c += \" ZEROFILL\";\n        } else if (column.unsigned) {\n            throw new Error(`NYI: spanner: column.unsigned`); // c += \" UNSIGNED\";\n        }\n\n        // spanner\n        if (column.enum)\n            throw new Error(`NYI: spanner: column.enum`); // c += ` (${column.enum.map(value => \"'\" + value + \"'\").join(\", \")})`;\n\n        // spanner only supports utf8\n        if (column.charset && column.charset.toLowerCase().indexOf(\"utf8\") >= 0)\n            throw new Error(`NYI: spanner: column.charset = ${column.charset}`); // c += ` CHARACTER SET \"${column.charset}\"`;\n        if (column.collation)\n            throw new Error(`NYI: spanner: column.collation`); // c += ` COLLATE \"${column.collation}\"`;\n\n        if (!column.isNullable)\n            c += \" NOT NULL\";\n\n        // explicit nullable modifier not supported. silently ignored.\n        // if (column.isNullable) c += \" NULL\";\n\n        // primary key can be specified only at table creation\n        // not error but does not take effect here.\n        // if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n\n        // spanner does not support any generated columns, nor default value.\n        // we should create metadata table and get information about generated columns\n        // if (column.isGenerated && column.generationStrategy === \"increment\") {\n        // }\n\n        // does not support comment.\n        if (column.comment)\n            throw new Error(`NYI: spanner: column.comment`); //c += ` COMMENT '${column.comment}'`;\n\n        // spanner ddl does not support any default value except SpannerColumnUpdateWithCommitTimestamp\n        // other default value is supported by extend schema table\n        if (column.default !== undefined && column.default !== null) {\n            if (column.default === SpannerColumnUpdateWithCommitTimestamp) {\n                c += `OPTIONS (allow_commit_timestamp=true)`\n            }\n        }\n\n        // does not support on update\n        if (column.onUpdate)\n            throw new Error(`NYI: spanner: column.onUpdate`); //c += ` ON UPDATE ${column.onUpdate}`;\n\n        return c;\n    }\n\n    protected buildCreateColumnOptionsSql(column: TableColumn): string {\n        return \"\";\n    }\n\n    protected replaceCachedTable(table: Table, changedTable: Table|null): void {\n        if (changedTable) {\n            super.replaceCachedTable(table, changedTable);\n            this.driver.setTable(changedTable);\n        } else {\n            const index = this.loadedTables.findIndex((t) => t.name == table.name);\n            if (index >= 0) {\n                this.loadedTables.splice(index, 1);\n            }\n        }\n    }\n\n    protected getSyncExtendSchemaObjects(table: SpannerExtendedTableProps, column: SpannerExtendedColumnProps): {\n        add: {table:string, column:string, type: string, value: string}[],\n        remove: {table:string, column:string, type: string}[]\n    } {\n        const ret = {\n            add: <{table:string, column:string, type: string, value: string}[]>[],\n            remove: <{table:string, column:string, type: string}[]>[]\n        };\n        if (column.default !== undefined) {\n            const defaultValue = this.driver.encodeDefaultValueGenerator(column.default);\n            ret.add.push({table: table.name, column: column.databaseName, type: \"default\", value: defaultValue});\n        } else {\n            if (column.isNullable) {\n                const defaultValue = this.driver.encodeDefaultValueGenerator(null);\n                ret.add.push({table: table.name, column: column.databaseName, type: \"default\", value: defaultValue});\n            } else {\n                ret.remove.push({table: table.name, column: column.databaseName, type: \"default\"});\n            }\n        }\n        if (column.generationStrategy) {\n            ret.add.push({table: table.name, column: column.databaseName, type: \"generator\", value: column.generationStrategy});\n        } else {\n            ret.remove.push({table: table.name, column: column.databaseName, type: \"generator\"});\n        }\n        return ret;\n    }\n\n    protected async deleteExtendSchema(table: string, column?: string, type?: string): Promise<void> {\n        const wh = column ? (\n            type ?\n                `\\`table\\` = '${table}' AND \\`column\\` = '${column}' AND \\`type\\` = '${type}'` :\n                `\\`table\\` = '${table}' AND \\`column\\` = '${column}'`\n        ) : (\n            `\\`table\\` = '${table}'`\n        );\n        const qb = this.connection.manager\n            .createQueryBuilder(this)\n            .delete()\n            .from(this.driver.options.schemaTableName || \"schemas\")\n            .where(wh);\n        return this.delete(qb);\n    }\n\n    protected async upsertExtendSchema(table: string, column: string, type: string, value: string): Promise<void> {\n        const qb = this.connection.manager\n            .createQueryBuilder(this)\n            .update(this.driver.options.schemaTableName || \"schemas\")\n            .set(<any>{table, column, type, value})\n            .where(`\\`table\\` = '${table}' AND \\`column\\` = '${column}' AND \\`type\\` = '${type}'`);\n        return this.upsert(qb);\n    }\n}\n"],"sourceRoot":"../.."}